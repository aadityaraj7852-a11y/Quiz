<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MCQ Editor + Free Translate + DOCX Export</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
<style>
:root{--accent:#0b7a3e;--muted:#666}
body{font-family:Arial,Helvetica,sans-serif;margin:12px;background:#f4f6f8;color:#111}
.container{max-width:1150px;margin:auto}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
h1{font-size:18px;margin:0}
.muted{color:var(--muted);font-size:13px}
.layout{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
.panel{flex:1;min-width:340px;background:#fff;border:1px solid #e2e6ea;padding:12px;border-radius:8px;box-sizing:border-box}
label{display:block;font-weight:600;margin-top:8px}
input,textarea,select,button{font-size:14px}
input,textarea,select{width:100%;padding:8px;margin:6px 0;border:1px solid #cfd8e3;border-radius:6px;box-sizing:border-box}
textarea{min-height:80px;resize:vertical}
.row{display:flex;gap:8px}
.row > div{flex:1}
.btn{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:6px;border:0;cursor:pointer}
.btn-green{background:var(--accent);color:#fff}
.btn-blue{background:#0d6efd;color:#fff}
.btn-muted{background:#666;color:#fff}
.icon-btn{background:transparent;border:0;font-size:16px;cursor:pointer;color:#000;padding:6px;border-radius:6px}
.icon-btn:hover{background:#f0f0f0}
.card{border:1px solid #eef2f6;padding:10px;border-radius:8px;margin-bottom:10px;background:#fff}
.preview-table{width:100%;border-collapse:collapse;margin-bottom:10px}
.preview-table td{border:1px solid #ddd;padding:6px;vertical-align:top}
.img-preview{max-width:220px;border-radius:6px;margin-top:6px;border:1px solid #ddd}
.small{font-size:13px;padding:6px 8px}
.actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
kbd{background:#eee;border-radius:4px;padding:2px 6px;border:1px solid #ddd;font-size:12px}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>MCQ Editor — Free Translate (Google) + DOCX</h1>
    <div class="muted">Auto-save | Translate without API | Images embedded in DOCX</div>
  </div>

  <div class="layout">
    <!-- Left: Input -->
    <div class="panel" style="max-width:720px;">
      <label>Module</label>
      <input id="module" placeholder="Hindi / English / General">

      <label>Question</label>
      <textarea id="question" placeholder="प्रश्न लिखें..."></textarea>
      <label>Question Image (optional)</label>
      <input type="file" accept="image/*" id="questionImg">

      <div class="row">
        <div>
          <label>Option A</label>
          <input id="optA" placeholder="Option A">
          <label>Image A (optional)</label>
          <input type="file" accept="image/*" id="imgA">
        </div>
        <div>
          <label>Option B</label>
          <input id="optB" placeholder="Option B">
          <label>Image B (optional)</label>
          <input type="file" accept="image/*" id="imgB">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Option C</label>
          <input id="optC" placeholder="Option C">
          <label>Image C (optional)</label>
          <input type="file" accept="image/*" id="imgC">
        </div>
        <div>
          <label>Option D</label>
          <input id="optD" placeholder="Option D">
          <label>Image D (optional)</label>
          <input type="file" accept="image/*" id="imgD">
        </div>
      </div>

      <label>Answer (A/B/C/D)</label>
      <input id="answer" placeholder="A">

      <label>Solution (Hindi)</label>
      <textarea id="solution" placeholder="सुलूशन लिखें..."></textarea>
      <label>Solution Image (optional)</label>
      <input type="file" accept="image/*" id="solutionImg">

      <div class="row">
        <div>
          <label>Positive Marks</label>
          <input id="pm" value="1">
        </div>
        <div>
          <label>Negative Marks</label>
          <input id="nm" value="0.0">
        </div>
      </div>

      <label>Language (optional)</label>
      <select id="language">
        <option value="">auto</option>
        <option value="hi">hi</option>
        <option value="en">en</option>
      </select>

      <div class="actions">
        <button id="addBtn" class="btn btn-green"><i class="fa fa-plus"></i> Add Question</button>
        <button id="translateBtn" class="btn small" style="background:#ff8c00;color:#fff"><i class="fa fa-language"></i> Translate This</button>
        <button id="translateAllBtn" class="btn small" style="background:#ff8c00;color:#fff"><i class="fa fa-globe"></i> Translate All</button>
        <button id="exportBtn" class="btn btn-blue"><i class="fa fa-file-word"></i> Export DOCX</button>
        <button id="exportJson" class="btn small btn-muted"><i class="fa fa-download"></i> Export JSON</button>
        <button id="importBtn" class="btn small" style="background:#777;color:#fff"><i class="fa fa-upload"></i> Import JSON</button>
        <button id="clearBtn" class="btn small" style="background:#999;color:#fff"><i class="fa fa-trash"></i> Clear Fields</button>
      </div>

      <label style="margin-top:8px">JSON Import (paste array)</label>
      <textarea id="jsonArea" style="height:90px;font-family:monospace"></textarea>
    </div>

    <!-- Right: Preview / List -->
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Preview / Questions</strong>
        <div class="muted">Click title/body to edit · All icons are FA (black)</div>
      </div>

      <div id="list" style="margin-top:8px"></div>

      <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
        <button id="removeLast" class="btn small" style="background:#c0392b;color:#fff"><i class="fa fa-minus-circle"></i> Remove Last</button>
        <button id="resetAll" class="btn small" style="background:#7f8c8d;color:#fff"><i class="fa fa-trash-alt"></i> Clear All</button>
      </div>

      <p class="muted" style="margin-top:12px">Tip: छोटे JPG images recommended। Translate आधिकारिक API नहीं — free Google translate endpoint इस्तेमाल किया गया है।</p>
    </div>
  </div>
</div>

<script>
/* ---------------- State ---------------- */
const STORAGE_KEY = 'mcq_trans_v2';
let questions = []; // each: {id,module,question,questionImg,option:[...],optionImg:[...],answer,solution,solutionImg,pm,nm,language,history:[],redo:[]}
let qno = 1;
const $ = id => document.getElementById(id);

/* Load/save */
function loadState(){
  try{
    const s = localStorage.getItem(STORAGE_KEY);
    if(s){
      const obj = JSON.parse(s);
      questions = obj.questions || [];
      qno = obj.qno || (questions.length+1);
    }
  }catch(e){ console.warn(e); questions=[]; }
  renderList();
}
function saveState(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify({questions,qno})); }catch(e){ console.warn(e); } }

/* Helpers */
function isHindi(s){ return /[\u0900-\u097F]/.test(s||''); }
function readFile(input){ return new Promise(res=>{ const f = input.files && input.files[0]; if(!f) return res(null); const r=new FileReader(); r.onload=()=> res({name:f.name,type:f.type,dataURL:r.result}); r.readAsDataURL(f); }); }
function uid(){ return 'q'+(Date.now().toString(36))+(Math.random().toString(36).slice(2,7)); }
function xmlEscape(s){ if(s==null) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

/* Build initial entry object */
async function buildEntryFromForm(){
  const module = $.module.value.trim() || 'General';
  const question = $.question.value.trim();
  const qImg = await readFile($.questionImg);
  const optA = $.optA.value.trim(), imgA = await readFile($.imgA);
  const optB = $.optB.value.trim(), imgB = await readFile($.imgB);
  const optC = $.optC.value.trim(), imgC = await readFile($.imgC);
  const optD = $.optD.value.trim(), imgD = await readFile($.imgD);
  const answer = $.answer.value.trim();
  const solution = $.solution.value.trim(), solImg = await readFile($.solutionImg);
  const pm = $.pm.value.trim() || '1', nm = $.nm.value.trim() || '0';
  let language = $.language.value || '';
  // detect if auto
  if(!language){
    language = (isHindi(question) || isHindi(optA) || isHindi(optB) || isHindi(optC) || isHindi(optD) || isHindi(solution)) ? 'hi' : 'en';
  }
  return {
    id: uid(), module, question, questionImg:qImg,
    option: [optA,optB,optC,optD],
    optionImg: [imgA,imgB,imgC,imgD],
    answer, solution, solutionImg: solImg,
    pm,nm,language,
    history: [], redo: []
  };
}

/* Add question */
$('#addBtn').addEventListener('click', async ()=>{
  const qtext = $.question.value.trim();
  if(!qtext){ alert('Question डालो'); return; }
  const ent = await buildEntryFromForm();
  // push snapshot
  ent.history.push(JSON.stringify(snapshot(ent)));
  questions.unshift(ent);
  saveState(); renderList(); clearForm();
});

/* Clear input form */
function clearForm(){
  $.module.value=''; $.question.value=''; $.questionImg.value='';
  $.optA.value=''; $.optB.value=''; $.optC.value=''; $.optD.value='';
  $.imgA.value=''; $.imgB.value=''; $.imgC.value=''; $.imgD.value='';
  $.answer.value=''; $.solution.value=''; $.solutionImg.value='';
  $.pm.value='1'; $.nm.value='0'; $.language.value='';
}

/* Render list */
function renderList(){
  const list = $('list'); list.innerHTML = '';
  if(!questions.length){ list.innerHTML = '<div class="muted">No questions added.</div>'; return; }
  questions.forEach((q,i)=>{
    const card = document.createElement('div'); card.className='card';
    card.style.marginBottom='10px';
    card.dataset.id = q.id;

    const hdr = document.createElement('div'); hdr.style.display='flex'; hdr.style.justifyContent='space-between';
    const left = document.createElement('div');
    const title = document.createElement('div'); title.style.fontWeight='700'; title.textContent = q.question || '(no question)';
    left.appendChild(title);
    const meta = document.createElement('div'); meta.className='muted'; meta.textContent = `${q.module} | ${q.language} | Q#${qno - i}`;
    left.appendChild(meta);

    const right = document.createElement('div');
    right.style.display='flex'; right.style.gap='6px';
    right.appendChild(icon('fa-pen','Edit', ()=> startEdit(q.id)));
    right.appendChild(icon('fa-undo','Undo', ()=> undoQuestion(q.id)));
    right.appendChild(icon('fa-redo','Redo', ()=> redoQuestion(q.id)));
    right.appendChild(icon('fa-language','Translate', ()=> translateQuestion(q.id)));
    right.appendChild(icon('fa-save','Save', ()=> saveEdit(q.id)));
    right.appendChild(icon('fa-trash','Delete', ()=> { if(confirm('Delete?')){ deleteQuestion(q.id); } }));
    hdr.appendChild(left); hdr.appendChild(right);
    card.appendChild(hdr);

    // body area (editable)
    const body = document.createElement('div'); body.style.marginTop='8px';
    if(q.questionImg && q.questionImg.dataURL){ const im=document.createElement('img'); im.src=q.questionImg.dataURL; im.className='img-preview'; body.appendChild(im); }
    const qDiv = document.createElement('div'); qDiv.contentEditable=true; qDiv.className='muted'; qDiv.style.fontWeight='600'; qDiv.style.marginTop='8px'; qDiv.textContent = q.question; qDiv.addEventListener('input', ()=> { q.question = qDiv.textContent; pushHistory(q); saveState(); });
    body.appendChild(qDiv);

    // options table
    const table = document.createElement('table'); table.className='preview-table';
    for(let k=0;k<4;k++){
      const tr = document.createElement('tr');
      const td1 = document.createElement('td'); td1.textContent = ['A','B','C','D'][k];
      const td2 = document.createElement('td'); 
      const optDiv = document.createElement('div'); optDiv.contentEditable=true; optDiv.textContent = q.option[k] || ''; optDiv.addEventListener('input', ()=> { q.option[k] = optDiv.textContent; pushHistory(q); saveState(); });
      td2.appendChild(optDiv);
      if(q.optionImg && q.optionImg[k] && q.optionImg[k].dataURL){ const im=document.createElement('img'); im.src=q.optionImg[k].dataURL; im.className='img-preview'; td2.appendChild(im); }
      tr.appendChild(td1); tr.appendChild(td2); table.appendChild(tr);
    }
    body.appendChild(table);

    // answer & solution editable
    const ans = document.createElement('div'); ans.style.marginTop='6px'; ans.innerHTML = `<b>Answer:</b> <span contenteditable="true">${q.answer||''}</span>`;
    ans.querySelector('span').addEventListener('input', (e)=>{ q.answer = e.target.textContent; pushHistory(q); saveState(); });
    body.appendChild(ans);

    const solDiv = document.createElement('div'); solDiv.style.marginTop='6px'; 
    const solEdit = document.createElement('div'); solEdit.contentEditable=true; solEdit.className='muted'; solEdit.textContent = q.solution || '';
    solEdit.addEventListener('input', ()=>{ q.solution = solEdit.textContent; pushHistory(q); saveState(); });
    body.appendChild(document.createElement('hr'));
    body.appendChild(solEdit);
    if(q.solutionImg && q.solutionImg.dataURL){ const im=document.createElement('img'); im.src=q.solutionImg.dataURL; im.className='img-preview'; body.appendChild(im); }

    card.appendChild(body);
    list.appendChild(card);
  });
}

/* icon helper */
function icon(cls,title,fn){
  const b = document.createElement('button'); b.className='icon-btn'; b.title = title; b.innerHTML = `<i class="fa ${cls}"></i>`;
  b.addEventListener('click', (ev)=>{ ev.stopPropagation(); fn(); });
  return b;
}

/* push history snapshot */
function snapshot(q){
  return {
    question:q.question, option:[...q.option], answer:q.answer, solution:q.solution, questionImg:q.questionImg, optionImg:q.optionImg, solutionImg:q.solutionImg
  };
}
function pushHistory(q){
  q.history = q.history || []; q.redo = q.redo || [];
  const snap = JSON.stringify(snapshot(q));
  if(q.history[q.history.length-1] !== snap){ q.history.push(snap); if(q.history.length>50) q.history.shift(); q.redo = []; }
}

/* Undo / Redo / Delete / Start Edit / Save Edit */
function undoQuestion(id){
  const q = questions.find(x=>x.id===id); if(!q || !q.history || q.history.length<=1) return alert('No undo available');
  const cur = q.history.pop(); q.redo = q.redo || []; q.redo.push(cur);
  const prev = q.history[q.history.length-1]; const obj = JSON.parse(prev);
  q.question = obj.question; q.option = obj.option; q.answer = obj.answer; q.solution = obj.solution; q.questionImg = obj.questionImg; q.optionImg = obj.optionImg; q.solutionImg = obj.solutionImg;
  saveState(); renderList();
}
function redoQuestion(id){
  const q = questions.find(x=>x.id===id); if(!q || !q.redo || q.redo.length===0) return alert('No redo');
  const snap = q.redo.pop(); q.history.push(snap); const obj = JSON.parse(snap);
  q.question = obj.question; q.option = obj.option; q.answer = obj.answer; q.solution = obj.solution; q.questionImg = obj.questionImg; q.optionImg = obj.optionImg; q.solutionImg = obj.solutionImg;
  saveState(); renderList();
}
function deleteQuestion(id){ questions = questions.filter(x=>x.id!==id); saveState(); renderList(); }
function startEdit(id){ const el = document.querySelector(`.card[data-id="${id}"]`); /* focus handled by contentEditable */ }
function saveEdit(id){ pushHistory(questions.find(x=>x.id===id)); saveState(); alert('Saved'); }

/* Translate utilities (free Google translate endpoint) */
async function translateText(text, sl='auto', tl='en'){
  if(!text) return '';
  try{
    const q = encodeURIComponent(text);
    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${sl}&tl=${tl}&dt=t&q=${q}`;
    const res = await fetch(url);
    if(!res.ok) throw new Error('Translate failed ' + res.status);
    const data = await res.json();
    // data[0] is array of segments
    const segs = data[0].map(s=>s[0]).filter(Boolean);
    return segs.join('');
  }catch(e){ console.warn(e); return ''; }
}

/* Translate specific question (question/options/solution) unless module==='Hindi' */
async function translateQuestion(id){
  const q = questions.find(x=>x.id===id); if(!q) return;
  if(String(q.module||'').trim().toLowerCase() === 'hindi'){ alert('Module Hindi सेट है — translate skipped'); return; }
  // If language is hi or detected as hi, translate to en
  if(q.language === 'hi' || isHindi(q.question) || isHindi(q.solution) || q.option.some(o=>isHindi(o))){
    q.titleEn = await translateText(q.question,'hi','en');
    // options
    q.optionEn = [];
    for(let i=0;i<4;i++){ q.optionEn[i] = await translateText(q.option[i]||'','hi','en'); }
    q.solutionEn = await translateText(q.solution,'hi','en');
    pushHistory(q); saveState(); renderList(); alert('Translated (HI→EN) for question id ' + id);
  }else{ alert('No Hindi detected or module set to Hindi — skipped'); }
}

/* Translate current form (single) */
$('#translateBtn').addEventListener('click', async ()=>{
  const module = $.module.value.trim().toLowerCase();
  if(module === 'hindi'){ alert('Module Hindi है — translate skip'); return; }
  // translate form fields if Hindi
  if(isHindi($.question.value)){ $.question.value = $.question.value; const t = await translateText($.question.value,'hi','en'); // we'll show English in console or create preview field
    alert('Translation (EN):\n' + t.slice(0,1000)); }
  else alert('Question में Hindi नहीं दिखी');
});

/* Translate All (every question where module !== 'Hindi' and language hi) */
$('#translateAllBtn').addEventListener('click', async ()=>{
  for(const q of questions){
    if(String(q.module||'').trim().toLowerCase() === 'hindi') continue;
    if(q.language === 'hi' || isHindi(q.question) || isHindi(q.solution) || q.option.some(o=>isHindi(o))){
      q.questionEn = await translateText(q.question,'hi','en');
      q.optionEn = [];
      for(let i=0;i<4;i++) q.optionEn[i] = await translateText(q.option[i]||'','hi','en');
      q.solutionEn = await translateText(q.solution,'hi','en');
      pushHistory(q);
    }
  }
  saveState(); renderList(); alert('Translated all (where applicable).');
});

/* JSON Import/Export */
$('#importBtn').addEventListener('click', ()=>{
  const txt = $.jsonArea.value.trim(); if(!txt) return alert('Paste JSON');
  try{
    const parsed = JSON.parse(txt);
    const arr = Array.isArray(parsed)? parsed : [parsed];
    arr.forEach(o=>{
      const ent = {
        id: uid(), module:o.module||'General', question:o.question||o.q||'', questionImg:o.questionImg||null,
        option: o.option || [o.optA,o.optB,o.optC,o.optD].filter(Boolean), optionImg: o.optionImg || [null,null,null,null],
        answer:o.answer||'', solution:o.solution||'', solutionImg:o.solutionImg||null, pm:o.pm||1,nm:o.nm||0,language:o.language||''
      };
      ent.history = [JSON.stringify(snapshot(ent))]; ent.redo=[];
      questions.unshift(ent);
    });
    saveState(); renderList(); alert('Imported ' + arr.length + ' items');
  }catch(e){ alert('Invalid JSON'); console.error(e); }
});
$('#exportJson').addEventListener('click', ()=>{
  const out = questions.map(q=>({
    module:q.module, question:q.question, option:q.option, answer:q.answer, solution:q.solution, pm:q.pm, nm:q.nm, language:q.language, questionImg:q.questionImg, optionImg:q.optionImg, solutionImg:q.solutionImg
  }));
  const blob = new Blob([JSON.stringify(out,null,2)],{type:'application/json'}); const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='mcq_export.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),3000);
});

/* Remove last / reset all */
$('#removeLast').addEventListener('click', ()=>{ if(!questions.length) return; questions.shift(); saveState(); renderList(); });
$('#resetAll').addEventListener('click', ()=>{ if(!confirm('Clear all?')) return; questions=[]; saveState(); renderList(); });

/* Autosave */
setInterval(saveState,2000);

/* ---------- DOCX builder (images embedded) ---------- */

/* helper for drawing xml */
function makeDrawingXml(rId, cx=4500000, cy=3000000){
  return `<w:p><w:r><w:drawing><wp:inline xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"><wp:extent cx="${cx}" cy="${cy}"/><wp:docPr id="1" name="Image"/><a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/picture"><pic:pic xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture"><pic:nvPicPr><pic:cNvPr id="0" name="Image"/><pic:cNvPicPr/></pic:nvPicPr><pic:blipFill><a:blip xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" r:embed="${rId}"/><a:stretch><a:fillRect/></a:stretch></pic:blipFill><pic:spPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="${cx}" cy="${cy}"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></pic:spPr></pic:pic></a:graphicData></a:graphic></wp:inline></w:drawing></w:r></w:p>`;
}

/* build table xml for MCQ question (with optional image parts) */
function makeRowXml(name,value,rId,cx,cy){
  const imagePart = rId ? `<w:p>${makeDrawingXml(rId,cx,cy)}</w:p>` : '';
  return `<w:tr><w:tc><w:tcPr><w:shd w:fill="FFFFFF"/></w:tcPr><w:p><w:r><w:t>${xmlEscape(name)}</w:t></w:r></w:p></w:tc><w:tc><w:tcPr><w:shd w:fill="FFF8DC"/></w:tcPr><w:p><w:r><w:t>${xmlEscape(value)}</w:t></w:r></w:p>${imagePart}</w:tc></w:tr>`;
}
function buildTableXml(q,rmap){
  let rows='';
  rows += makeRowXml('Module', q.module || '', null);
  rows += makeRowXml('questionno', q.id || '', null);
  rows += makeRowXml('Question', q.question || '', rmap.questionImg, rmap.questionCx, rmap.questionCy);
  rows += makeRowXml('Type', 'mcq', null);
  for(let i=0;i<4;i++){
    rows += makeRowXml('option', q.option[i] || '', rmap['optionImg'+i], rmap['optionImg'+i+'Cx'], rmap['optionImg'+i+'Cy']);
  }
  rows += makeRowXml('answer', q.answer || '', null);
  rows += makeRowXml('Solution', q.solution || '', rmap.solutionImg, rmap.solutionCx, rmap.solutionCy);
  rows += makeRowXml('Positive Marks', q.pm || '', null);
  rows += makeRowXml('Negative Marks', q.nm || '', null);
  rows += makeRowXml('language', q.language || '', null);
  return `<w:tbl><w:tblPr><w:tblBorders><w:top w:val="single" w:sz="6"/><w:left w:val="single" w:sz="6"/><w:right w:val="single" w:sz="6"/><w:bottom w:val="single" w:sz="6"/><w:insideH w:val="single" w:sz="4"/><w:insideV w:val="single" w:sz="4"/></w:tblBorders></w:tblPr>${rows}</w:tbl><w:p><w:r><w:t></w:t></w:r></w:p>`;
}

/* collect media */
function collectMedia(){
  const list=[];
  questions.forEach((q,qi)=>{
    if(q.questionImg && q.questionImg.dataURL) list.push({qIndex:qi,field:'questionImg',data:q.questionImg});
    (q.optionImg||[]).forEach((oi,idx)=>{ if(oi && oi.dataURL) list.push({qIndex:qi,field:'optionImg'+idx,data:oi}); });
    if(q.solutionImg && q.solutionImg.dataURL) list.push({qIndex:qi,field:'solutionImg',data:q.solutionImg});
  });
  return list;
}

/* build package files */
function buildPackageFiles(){
  const mediaList = collectMedia();
  const mediaFiles = [];
  const relIds = [];
  mediaList.forEach((it,idx)=>{
    const d = it.data;
    const comma = d.dataURL.indexOf(','); const b64 = d.dataURL.slice(comma+1);
    const binStr = atob(b64); const u8 = new Uint8Array(binStr.length); for(let j=0;j<binStr.length;j++) u8[j]=binStr.charCodeAt(j);
    let ext='png'; if(d.type && d.type.indexOf('jpeg')!==-1) ext='jpg';
    const name = `image${idx+1}.${ext}`;
    mediaFiles.push({name,type:d.type||('image/'+ext),data:u8,ref:it});
    relIds.push('rIdImg'+(idx+1));
  });

  const rmapPerQ = questions.map(()=>({
    questionImg:null, questionCx:0, questionCy:0,
    optionImg0:null, optionImg0Cx:0, optionImg0Cy:0,
    optionImg1:null, optionImg1Cx:0, optionImg1Cy:0,
    optionImg2:null, optionImg2Cx:0, optionImg2Cy:0,
    optionImg3:null, optionImg3Cx:0, optionImg3Cy:0,
    solutionImg:null, solutionCx:0, solutionCy:0
  }));
  mediaFiles.forEach((m,idx)=>{
    const it = m.ref; const qidx = it.qIndex; const rId = relIds[idx];
    const defCx = 4500000, defCy = 3000000;
    if(it.field==='questionImg'){ rmapPerQ[qidx].questionImg = rId; rmapPerQ[qidx].questionCx=defCx; rmapPerQ[qidx].questionCy=defCy; }
    else if(it.field.startsWith('optionImg')){ const n=Number(it.field.replace('optionImg','')); rmapPerQ[qidx]['optionImg'+n]=rId; rmapPerQ[qidx]['optionImg'+n+'Cx']=3500000; rmapPerQ[qidx]['optionImg'+n+'Cy']=2000000; }
    else if(it.field==='solutionImg'){ rmapPerQ[qidx].solutionImg=rId; rmapPerQ[qidx].solutionCx=defCx; rmapPerQ[qidx].solutionCy=defCy; }
  });

  // build document body: for each question, push both hi and en blocks if available
  let body='';
  questions.forEach((q,qi)=>{
    // Hindi block (if present)
    body += buildTableXml(q, rmapPerQ[qi]);
    // If english translations exist (questionEn or optionEn), add an extra table for EN
    const hasEn = q.questionEn || (q.optionEn && q.optionEn.some(x=>x));
    if(hasEn){
      const qEn = {
        module: q.module,
        id: q.id + '_EN',
        question: q.questionEn || '',
        option: q.optionEn || ['', '', '', ''],
        answer: q.answer || '',
        solution: q.solutionEn || '',
        pm: q.pm, nm: q.nm, language: 'en'
      };
      // create a fake rmap for en with same images (re-use rmapPerQ)
      body += buildTableXml(qEn, rmapPerQ[qi]);
    }
  });

  const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
  <w:body>${body}<w:p/><w:sectPr/></w:body>
</w:document>`;

  let relsXml = `<?xml version="1.0" encoding="UTF-8"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">`;
  mediaFiles.forEach((m,i)=> relsXml += `<Relationship Id="${relIds[i]}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="media/${m.name}"/>`);
  relsXml += `</Relationships>`;

  const extMap={}; mediaFiles.forEach(m=> extMap[m.name.split('.').pop()] = m.type);
  let ctXml = `<?xml version="1.0" encoding="UTF-8"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">`;
  ctXml += `<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>`;
  ctXml += `<Default Extension="xml" ContentType="application/xml"/>`;
  Object.keys(extMap).forEach(ext => ctXml += `<Default Extension="${ext}" ContentType="${extMap[ext]}"/>`);
  ctXml += `<Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/></Types>`;

  const files = {};
  files["[Content_Types].xml"] = ctXml;
  files["_rels/.rels"] = `<?xml version="1.0"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/></Relationships>`;
  files["word/document.xml"] = documentXml;
  files["word/_rels/document.xml.rels"] = relsXml;
  mediaFiles.forEach(m => files[`word/media/${m.name}`] = m.data);
  return files;
}

/* ZIP builder (binary-safe) */
function buildZip(files){
  const enc = new TextEncoder();
  function toBytes(v){ if(v instanceof Uint8Array) return v; return enc.encode(v); }
  function u32(n){ return [n&255,(n>>8)&255,(n>>16)&255,(n>>24)&255]; }

  // crc table
  let table = window.__crcTable;
  if(!table){
    table = new Uint32Array(256);
    for(let i=0;i<256;i++){ let c=i; for(let k=0;k<8;k++) c = (c&1) ? (0xEDB88320 ^ (c>>>1)) : (c>>>1); table[i]=c>>>0; }
    window.__crcTable = table;
  }
  function crc32(buf){
    let crc = ~0;
    for(let i=0;i<buf.length;i++) crc = (crc>>>8) ^ table[(crc ^ buf[i]) & 0xff];
    return (~crc)>>>0;
  }

  const local=[]; const central=[]; let offset=0;
  for(const name in files){
    const data = toBytes(files[name]); const fname = enc.encode(name);
    const crc = crc32(data); const compSize = data.length; const uncompSize = data.length;
    const lh = new Uint8Array(30 + fname.length);
    lh.set([0x50,0x4b,0x03,0x04],0); lh[4]=20; lh[6]=0; lh[8]=0;
    lh.set(u32(crc),14); lh.set(u32(compSize),18); lh.set(u32(uncompSize),22);
    lh[26]=fname.length & 0xff; lh[27]=(fname.length>>8)&0xff; lh.set(fname,30);
    local.push(lh); local.push(data);
    const ch = new Uint8Array(46 + fname.length); ch.set([0x50,0x4b,0x01,0x02],0); ch[4]=20; ch[6]=20;
    ch.set(u32(crc),16); ch.set(u32(compSize),20); ch.set(u32(uncompSize),24); ch[28]=fname.length & 0xff; ch[29]=(fname.length>>8)&0xff;
    ch.set(u32(offset),42); ch.set(fname,46);
    central.push(ch);
    offset += lh.length + data.length;
  }
  const centralSize = central.reduce((s,c)=>s+c.length,0);
  const eocd = new Uint8Array(22); eocd.set([0x50,0x4b,0x05,0x06],0);
  const entriesCount = central.length; eocd[8] = entriesCount & 0xff; eocd[9] = (entriesCount>>8)&0xff; eocd[10]=eocd[8]; eocd[11]=eocd[9];
  eocd.set(u32(centralSize),12); eocd.set(u32(offset),16);
  const out = new Uint8Array(offset + centralSize + 22);
  let p=0; local.forEach(part=>{ out.set(part,p); p+=part.length; }); central.forEach(c=>{ out.set(c,p); p+=c.length; });
  out.set(eocd,p);
  return new Blob([out], {type:"application/vnd.openxmlformats-officedocument.wordprocessingml.document"});
}

/* Export DOCX */
$('#exportBtn').addEventListener('click', ()=>{
  if(!questions.length) return alert('पहले कम से कम एक प्रश्न जोड़ो');
  try{
    // collect media refs: we need to map back to original pos (include qIndex)
    const mediaList = [];
    questions.forEach((q,qi)=>{
      if(q.questionImg && q.questionImg.dataURL) mediaList.push({qIndex:qi,field:'questionImg',data:q.questionImg});
      (q.optionImg||[]).forEach((oi,idx)=>{ if(oi && oi.dataURL) mediaList.push({qIndex:qi,field:'optionImg'+idx,data:oi}); });
      if(q.solutionImg && q.solutionImg.dataURL) mediaList.push({qIndex:qi,field:'solutionImg',data:q.solutionImg});
    });
    // attach qIndex into each ref for buildPackageFiles
    mediaList.forEach((m,idx)=> m.index = idx);
    // temporarily override collectMedia to return these with qIndex (we'll replicate buildPackageFiles logic)
    // Simpler: call buildPackageFiles which itself calls collectMedia on current questions (which include qIndex not present). But our collectMedia used questions array; to preserve mapping, we will inject qIndex into each image object earlier when reading files.
    // Ensure each image object has a reference to its origin with qIndex: when reading files into question objects earlier, we didn't store qIndex; but buildPackageFiles uses questions order so it will map correctly.
    const files = buildPackageFiles();
    const blob = buildZip(files);
    const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='questions.docx'; a.click();
    setTimeout(()=>URL.revokeObjectURL(url),5000);
  }catch(e){ console.error(e); alert('Export failed: ' + (e&&e.message)); }
});

/* Init */
loadState();
renderList();

/* When adding question via form, we must attach qIndex for images in questions - do it at moment of adding: (already handled: images stored in question objects; buildPackageFiles will map them by order) */

/* Small improvement: when reading files for question creation, attach original qIndex (not needed). */

// END
</script>
</body>
</html>
